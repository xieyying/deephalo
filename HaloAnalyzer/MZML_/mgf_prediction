import sys
sys.path.append(r'\Users\xyy\Desktop\python\HaloAnalyzer')

from pyteomics import mzml ,mgf
import numpy as np
import pandas as pd
from molmass import Formula
import tensorflow as tf
import os
from HaloAnalyzer.Model import model_build

# your code here
def formula_clf(formula_dict,type=None) :
    """
    Returns a classifier based on the formula given.
    """

    #根据分子式，判断是否可训练
    if formula_dict.get('H') == None or formula_dict.get('C') == None:
        trainable = 'no'
    elif formula_dict.get('H') < 1 or formula_dict.get('C') < 1:
        trainable = 'no'
    elif formula_dict.get('S') != None and formula_dict.get('S') > 4:
        trainable = 'no'
    else:
        trainable = 'yes'

    #根据分子式，判断类别
    if type == 'hydro':
        group = 7

    elif ('Br' in formula_dict.keys()) and ('Cl' in formula_dict.keys()):
        if 'B' in formula_dict.keys() or 'Se' in formula_dict.keys() or 'Fe' in formula_dict.keys():
            group = 17
        else:
            group = 0

    elif ('Br' in formula_dict.keys()) or ('Cl' in formula_dict.keys()):
        if 'B' in formula_dict.keys() or 'Se' in formula_dict.keys() or 'Fe' in formula_dict.keys():
            group = 17
        elif ('Br' in formula_dict.keys()) and formula_dict['Br']>1:
           
            group = 0

        elif ('Cl' in formula_dict.keys()) and formula_dict['Cl']>3:
            group = 0
          
        elif ('Br' in formula_dict.keys()) and formula_dict['Br']==1 :
            group = 1
        elif ('Cl' in formula_dict.keys()) and formula_dict['Cl']==3:
            group = 1
        elif ('Cl' in formula_dict.keys()) and formula_dict['Cl']>=1:
            group = 2
    elif ('Se' in formula_dict.keys() ):
        if formula_dict['Se']==1:
            group = 3
        else:
            group = 15
    elif ('B' in formula_dict.keys()):
        if  formula_dict['B']==1:
            group = 4
        elif formula_dict['B']<=4:
            group = 12
        else:
            group = 13
    elif ('Fe' in formula_dict.keys()):
        if formula_dict['Fe']==1:
            group = 5
        else:
            group = 14
    elif 'S' in formula_dict.keys():
        if formula_dict['S']<=3:
            group = 8
        elif formula_dict['S']==4:
            group = 8
        elif formula_dict['S']==5:
            group = 8
        else:
            group = 8

    else:
        group = 6

    return trainable,group


def mass_spectrum_calc_2(dict_features) -> dict:
    """校正质谱数据"""
    # 将以最高峰为a0的质谱数据转化为以mz最小的峰为new_a0的质谱数据
    mz_list = [dict_features['mz_b3'],dict_features['mz_b2'],dict_features['mz_b1'],dict_features['mz_a0'],dict_features['mz_a1'],dict_features['mz_a2'],dict_features['mz_a3']]
    ints_list = [dict_features['ints_b3'],dict_features['ints_b2'],dict_features['ints_b1'],1,dict_features['ints_a1'],dict_features['ints_a2'],dict_features['ints_a3']]
    for i in range(len(ints_list)):
        if ints_list[i] != 0:
            index = i
            break
    new_a0_mz,new_a1_mz,new_a2_mz,new_a3_mz = mz_list[index],mz_list[index+1],mz_list[index+2],mz_list[index+3]
    new_a0_ints,new_a1_ints,new_a2_ints,new_a3_ints = ints_list[index],ints_list[index+1],ints_list[index+2],ints_list[index+3]
    

    if new_a2_mz !=0:
        new_a2_a1 = new_a2_mz - new_a1_mz
        new_a2_a0 = new_a2_mz - new_a0_mz
    else:
        new_a2_a1 = 1.002
        new_a2_a0 = 2.002
    
    if new_a1_mz != 0:
        new_a1_a0 = new_a1_mz - new_a0_mz
    else:
        new_a1_a0 = 1.002

    new_a2_a0_10 = (new_a2_a0-1)**10
    new_a2_a1_10 = new_a2_a1**10
    new_a2_a1_15 = new_a2_a1**15
    new_a1_a0_30 = new_a1_a0**30
    new_a2_a1_20 = new_a2_a1**20 
    new_a1_a0_10 = new_a1_a0**10

    #以字典的形式返回
    return {'new_a0_mz':new_a0_mz,'new_a1_mz':new_a1_mz,'new_a2_mz':new_a2_mz,'new_a3_mz':new_a3_mz,
            'new_a0_ints':new_a0_ints,'new_a1_ints':new_a1_ints,'new_a2_ints':new_a2_ints,'new_a3_ints':new_a3_ints,
            'new_a2_a1':new_a2_a1,'new_a2_a0':new_a2_a0,
            'new_a2_a0_10':new_a2_a0_10,'new_a2_a1_10':new_a2_a1_10,'new_a2_a1_15':new_a2_a1_15,'new_a1_a0_30':new_a1_a0_30,\
                'new_a2_a1_20':new_a2_a1_20,'new_a1_a0':new_a1_a0,'new_a1_a0_10':new_a1_a0_10}


#误差范围也需要同步传递
def get_mz_max(mz,intensity,target_mz):
    #获取mz中与target_mz相差在0.02的所有mz
    mz_list1 = mz[np.abs(mz-target_mz)<0.02]
    ints_list1 = intensity[np.abs(mz-target_mz)<0.02]
    #获取mz_list1中intensity最大的mz
    mz_max1 = mz_list1[np.argmax(ints_list1)]
    #获取mz_max1对应的intensity
    # intensity_max1 = intensity[np.argmax(intensity[np.abs(mz-target_mz)<0.02])]
    intensity_max1 = ints_list1.max()
    
    #获取mz中与target_mz相差在-3.1和+3.1的所有mz
    mz_list2_index = pd.Series(mz).between((target_mz-3.1),(target_mz+3.1))
    mz_list2 = mz[mz_list2_index]
    ints_list2 = intensity[mz_list2_index]
    #获取mz_list2中intensity最大的mz
    mz_max2 = mz_list2[np.argmax(ints_list2)]
    #获取mz_max2对应的intensity
    # intensity_max2 = intensity[np.argmax(intensity[mz_list2_index])]
    intensity_max2 = ints_list2.max()
    #以字典的形式返回
    return {'mz_list1':mz_list1,'ints_list1':ints_list1,'mz_max1':mz_max1,'intensity_max1':intensity_max1,'mz_list2':mz_list2,'ints_list2':ints_list2,'mz_max2':mz_max2,'intensity_max2':intensity_max2}

#暂未修改
def get_charge(mz_list,ints_list,intensity_max):
    mz_charge_list = mz_list
    ints_charge_list = ints_list/intensity_max
    #选取mz_charge_list中强度最大的前5个峰
    #若不足五个峰，则选取全部
    if len(mz_charge_list) >= 5:
        a = mz_charge_list[ints_charge_list.argsort()[-5:][::-1]]
    else:
        #按照强度顺序排列
        a = mz_charge_list[ints_charge_list.argsort()[::-1]]
    b = []
    for i in a:
        for j in a:
            b.append(i-j)
    b = np.array(b)
    
    b = b.reshape(len(a),len(a))
    # print(b)a
    for i in range(0,len(b)):
        for j in range(0,len(b)):
            if abs(b[i][j] - 1) < 0.02:
                b[i][j] = 1
            elif abs(b[i][j] - 0.5) < 0.02:
                b[i][j] = 0.5
            elif abs(b[i][j] - 0.33) < 0.02:
                b[i][j] = 0.33
            else:
                b[i][j] = 0
    # print(b)
    c = {}
    for i in range(0,len(b)):
        for j in range(0,len(b)):
            if b[i][j] in c:
                c[b[i][j]] += 1
            else:
                c[b[i][j]] = 1
    # print(c)
    d = 0
    for i in c:
        if i != 0:
            if c[i] > d:
                d = c[i]
                e = i
    if d == 0:
        return 0
    if e == 1:
        return 1
    elif e == 0.5:
        return 2
    elif e == 0.33:
        return 3
    else:
        return 0

def get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,delta_mz,error=0.01):
    
    """
    以最高峰为基准，获取与其相差delta_mz的同位素峰的mz和intensity;
    考虑电荷
    允许误差范围为error
    """

    mz = [i for i, x in enumerate(mz_list) if (mz_max+(delta_mz-error)/charge) <= x <= (mz_max+(delta_mz+error)/charge)]
    if len(mz) != 0:
        ints = [ints_list[i] for i in mz]
        mz = mz_list[max(mz, key=lambda i: ints_list[i])]
        ints = max(ints)
    else:
        mz = 0
        ints = 0
    return mz,ints

def get_isotopic_peaks(mz_max,mz_list,ints_list,charge):
    """
    以最高峰为基准，获取同位素峰的mz和intensity;

    """
    mz_b3,ints_b3 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,-2.993)
    mz_b2,ints_b2 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,-2.000)
    mz_b1,ints_b1 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,-0.998)
    mz_a0,ints_a0 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,0.000)
    mz_a1,ints_a1 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,1.001)
    mz_a2,ints_a2 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,2.002)
    mz_a3,ints_a3 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,3.003)

    ints_b3,ints_b2,ints_b1,ints_a0,ints_a1,ints_a2,ints_a3 = ints_b3/ints_a0,\
    ints_b2/ints_a0,ints_b1/ints_a0,ints_a0/ints_a0,ints_a1/ints_a0,ints_a2/ints_a0,ints_a3/ints_a0
    mz_b3,mz_b2,mz_b1,mz_a0,mz_a1,mz_a2,mz_a3 = mz_b3*charge,mz_b2*charge,mz_b1*charge,mz_a0*charge,mz_a1*charge,mz_a2*charge,mz_a3*charge
    
    # 根据base数据统计结果去除掉低强度信号，防止背景信号影响
    # min_int_b3: 0.000217286018714 min_int_b1: 0.001998024679028 min_int_b2: 0.0446544604098983 
    # min_int_a1: 0.0218262955587414 min_int_a2: 0.0001238175919807 min_int_a3: 1.244083605286354e-06

    # 根据base数据中含卤素化合物的统计结果去除掉低强度信号，防止背景信号影响
    # min_int_b3: 0.004641895871693 min_int_b1: 0.0075301904935026 min_int_b2: 0.0510192731491299 
    # min_int_a1: 0.0219387819677692 min_int_a2: 0.0265888647368106 min_int_a3: 0.000947965881822

    if ints_b1 < 0.001:
        mz_b1 = 0
        ints_b1 = 0
        mz_b2 = 0
        ints_b2 = 0
        mz_b3 = 0
        ints_b3 = 0
    else:
        if ints_b2 < 0.04:
            mz_b2 = 0
            ints_b2 = 0
            mz_b3 = 0
            ints_b3 = 0
        else:
            if ints_b3 < 0.0002:
                mz_b3 = 0
                ints_b3 = 0
    # 根据b2判断b1是否为杂信号
    # 根据卤化物统计b2为0b1最小为0.223073，根据全部base统计b2为0时b1最小值为0.202336
    if ints_b2 ==0:
        if ints_b1 < 0.15:
            mz_b1 = 0
            ints_b1 = 0
            mz_b2 = 0
            ints_b2 = 0
            mz_b3 = 0
            ints_b3 = 0
    
    if ints_a1 < 0.02:
        mz_a1 = 0
        ints_a1 = 0
        mz_a2 = 0
        ints_a2 = 0
        mz_a3 = 0
        ints_a3 = 0
    if mz_a2!=0 and mz_a1!=0:
        a2_a1 = mz_a2-mz_a1
    else:
        a2_a1 = 1.002
    a2_a1_10 = a2_a1**10

    #以字典的形式返回
    return {'a2_a1':a2_a1,'mz_b3':mz_b3,'ints_b3':ints_b3,'mz_b2':mz_b2,'ints_b2':ints_b2,'mz_b1':mz_b1,'ints_b1':ints_b1,'mz_a0':mz_a0,'ints_a0':ints_a0,'mz_a1':mz_a1,'ints_a1':ints_a1,'mz_a2':mz_a2,'ints_a2':ints_a2,'mz_a3':mz_a3,'ints_a3':ints_a3,'a2_a1_10':a2_a1_10}

def is_halo_isotopes(b_3,b_2,b_1,a0,a1,a2,a3):
    """
    根据六个个同位素峰的强度,判断是否为同位素峰
    判断主要依据卤化物的同位素峰强度的统计结果
    """
    # if a1>0.02:
    #     if b_2 == 0:
    #         if b_1==0:
    #             is_isotope = 1
    #         else:
    #             if  b_1 > 0.5:
    #                 is_isotope = 1
    #             else:
    #                 is_isotope = 0
    #     else:
    #         if b_2>0.3:
    #             if b_1>0.02:
    #                is_isotope = 1
    #             else:
    #                 is_isotope = 0
    #         else:
    #             is_isotope = 0
    # else:
    #     is_isotope =0

    # return is_isotope
    if a1>0.02:
        if b_3 == 0:
            is_isotope = 1
        else:
            if b_2 > 0.04:
                is_isotope = 1
            else:
                is_isotope = 0
    else:
        is_isotope =0
    return is_isotope
    
def calculate_zig_zag(I):
    """
    根据一个ROI中所有scan的分类结果，计算ZigZag score
    I:list，为一个ROI中所有scan的分类结果
    """
    # Calculate the maximum and minimum values of I
    Imax= max(I)
    Imin = min(I)
    N = len(I) 
    total = 0
    # Calculate the ZigZag score for I
    for n in range(1,N-1):
        term = (2 * I[n] - I[n - 1] - I[n + 1])**2 

        total += term
    zigzag = total/(N*(Imax-Imin)**2)

    # Convert the ZigZag score to a percentage
    score = (4-8/N-zigzag)/(4-8/N)*100
    # score = (4-8/N-zigzag)/(4-8/N)*100
    return score

def get_max(a):
    '''a 为dict格式的同位素峰数据'''

    # 获得intesity 100%的mz
    for key,value in a.items():
        if round(value[2],4) == 100:
            mz_base = value[0]
        
            break
    return mz_base

def get_cal_mz(formula,mz,ints):
    # get mz_max of formula isotopic pattern
    a = Formula(formula+'H').spectrum().asdict()
    mz_max = get_max(a)            

    mz_list1 = mz[np.abs(mz-mz_max)<0.3]
    ints_list1 = ints[np.abs(mz-mz_max)<0.3]
    if len(mz_list1) != 0:
        precursor_mz = mz_list1[np.argmax(ints_list1)]
        charge_t =1
        # print(precursor_mz)
    else:
        a = Formula(formula+"H"+'H').spectrum().asdict()
        mz_max = get_max(a)
        mz_list1 = mz[np.abs(mz-mz_max/2)<0.3]
        ints_list1 = ints[np.abs(mz-mz_max/2)<0.3]
        if len(mz_list1) != 0:
            precursor_mz = mz_list1[np.argmax(ints_list1)]
            # print(precursor_mz)
            charge_t =2
        else:
            a = Formula(formula+"H"+'H'+'H').spectrum().asdict()
            mz_max= get_max(a)
            mz_list1 = mz[np.abs(mz-mz_max/3)<0.3]
            ints_list1 = ints[np.abs(mz-mz_max/3)<0.3]
            if len(mz_list1) != 0:
                precursor_mz = mz_list1[np.argmax(ints_list1)]
                # print(precursor_mz)
                charge_t =3
            else:
                a = (Formula(formula)-Formula('H')).spectrum().asdict()
                mz_max = get_max(a)
                mz_list1 = mz[np.abs(mz-mz_max)<0.3]
                ints_list1 = ints[np.abs(mz-mz_max)<0.3]
                if len(mz_list1) != 0:
                    precursor_mz = mz_list1[np.argmax(ints_list1)]
                    # print(precursor_mz)
                    charge_t =1
                else:
                    # print('more than 3 charges')
                    precursor_mz = 0
                    charge_t =0
                    
    return precursor_mz, mz_max,charge_t

class mgf_pred():
    def __init__(self,file) -> None:
        self.path = file
        self.spectra = mgf.MGF(file)
        


    def get_new(self):
       
        mgf_extracted = []

        mgf_patterns = []
        
   
        df = pd.DataFrame()
        ts = 0
        for spectrum in self.spectra:
            ts+=1
            mgf_  ={}
            mz = spectrum['m/z array']
            ints = spectrum['intensity array']

            #如果mz中的数值准确到小数点后三位以下，则跳过此循环
            # if (mz*1000 % 1).all() == 0:
            #     continue

            # for MassBank
            try:
                formula = spectrum['params']['ch$formula']
                name = spectrum['params']['ch$name']

            except:
                # for myxo
                formula = spectrum['params']['formula']
                name = spectrum['params']['compound_name']


            # print(formula)

            #强度最低峰
            if ints.size == 0:
                print(formula,'ints is empty')
                continue
            min_int = ints.min()

             # 找到最强峰的index
            max_index = np.argmax(ints)
            max_mz = mz[max_index]
            max_int = ints[max_index]
            # ints = (ints-min_int)/(max_int-min_int)  # for full scan, 对于full scan这种处理比直接除以最大值好，具体表现在同位素提取更准确
            ints = ints/max_int  # for extracted future


            # 去掉峰强小于0.01的峰
            # mz = mz[ints>0.0001]
            # ints = ints[ints>0.0001]
            
            # precursor_mz,mz_max,charge_t = get_cal_mz(formula,mz,ints) # for extracted formula
            precursor_mz = max_mz # for max_mz in full scan
            if precursor_mz == 0:
                continue
            dict_mz_max = get_mz_max(mz, ints, precursor_mz)
            # print(dict_mz_max)
            charge = get_charge(dict_mz_max['mz_list2'],dict_mz_max['ints_list2'],dict_mz_max['intensity_max2'])
            if charge!=0:
                # if charge_t != charge:
                #     print('charge is not equal')
                #     continue
                
                dict_isotoplogues = get_isotopic_peaks(dict_mz_max['mz_max2'],dict_mz_max['mz_list2'],dict_mz_max['ints_list2'],charge)
                is_halo = is_halo_isotopes(dict_isotoplogues['ints_b3'],dict_isotoplogues['ints_b2'],dict_isotoplogues['ints_b1'],dict_isotoplogues['ints_a0'],dict_isotoplogues['ints_a1'],dict_isotoplogues['ints_a2'],dict_isotoplogues['ints_a3'])
                if is_halo == 1:
                    mgf_extracted.append(spectrum)
                    mz_iso = [dict_isotoplogues['mz_b3'],dict_isotoplogues['mz_b2'],dict_isotoplogues['mz_b1'],dict_isotoplogues['mz_a0'],dict_isotoplogues['mz_a1'],dict_isotoplogues['mz_a2'],dict_isotoplogues['mz_a3']]
                    ints_iso = [dict_isotoplogues['ints_b3'],dict_isotoplogues['ints_b2'],dict_isotoplogues['ints_b1'],dict_isotoplogues['ints_a0'],dict_isotoplogues['ints_a1'],dict_isotoplogues['ints_a2'],dict_isotoplogues['ints_a3']]
                    mgf_['params'] = spectrum['params']
                    # 非零mz和intensity
                    mgf_['m/z array'] = np.array(mz_iso)[np.array(mz_iso)!=0]
                    mgf_['m/z array'] =mgf_['m/z array'] * charge
                    mgf_['intensity array'] = np.array(ints_iso)[np.array(ints_iso)!=0]
                    # mgf_['m/z array'] = np.array(mz_iso)
                    # mgf_['intensity array'] = np.array(ints_iso)
                    mgf_patterns.append(mgf_)
            else:
                # print('charge is 0')
                continue
            monoisotope = get_max(Formula(formula).spectrum().asdict())
            true_class = formula_clf(Formula(formula).composition().dataframe().to_dict()['Count'])[1]


            #应该将函数的返回值修改为字典，可以避免重复修改此处代码    
            dict_new = mass_spectrum_calc_2(dict_isotoplogues)
            dict_new['charge'] = charge
            dict_new['formula'] = formula
            dict_new['mz_monoisotope'] = monoisotope
            dict_new['mz_precursor'] = precursor_mz
            dict_new['name'] = name
            dict_new['is_halo'] = is_halo
            dict_new['true_class'] = true_class
            dict_all = dict_isotoplogues.copy()
            dict_all.update(dict_new)
            df = pd.concat([df, pd.Series(dict_all)], axis=1)

        df = df.T
        # df = df[df['charge']!=0]
        # df = df[df['is_halo']==1]
        # df.to_csv('D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\myxo_abstracted_isotopes_features1.csv',index=False)
        # df.to_csv('D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\isotopes features.csv',index=False)
        # print(df)
        return df,mgf_extracted,mgf_patterns,ts

    def get_halo_spectrum(self):
        halo_formula = []
        
        mgf_halo = []

        for spectrum in self.spectra:
            # formula = spectrum['params']['ch$formula']
            try:
                formula = spectrum['params']['ch$formula']
                name = spectrum['params']['ch$name']

            except:
                # for myxo
                formula = spectrum['params']['formula']
                name = spectrum['params']['compound_name']

            true_class = formula_clf(Formula(formula).composition().dataframe().to_dict()['Count'])[1]
            if true_class in [0,1,2]:
                mgf_halo.append(spectrum)
                halo_formula.append(formula)

        return mgf_halo, halo_formula


def add_predict(df,model_path,features_list):
    
    #加载tf模型
    clf = tf.keras.models.load_model(model_path)
    #加载特征

    querys = df[features_list].values
    querys = querys.astype('float32')
    #对特征进行预测
    res = clf.predict(querys)
    # classes = tf.math.argmax(res[0],1).numpy()
    classes_pred = np.argmax(res, axis=1)
    #将预测结果添加到df_features中
    df['class_pred'] = classes_pred

    return df

if __name__ == '__main__':
    
    feature_list = [
        "ints_b3",
        "ints_b2",
        "ints_b1",
        "ints_a0",
        "ints_a1",
        "ints_a2",
        "ints_a3",
        "new_a2_a1_10",
        "new_a1_a0_10",
        "a2_a1_10",
    ]
    # model=r'C:\Users\xyy\Desktop\python\HaloAnalyzer_training\main10\trained_models\pick_halo_ann.h5'
    model = r'C:\Users\xyy\Desktop\python\HaloAnalyzer_training\020_main_1\trained_models\pick_halo_ann.h5'
    # model = r'C:\Users\xyy\Desktop\python\HaloAnalyzer_training\020_main_1\trained_models\picked_models\pick_halo_ann_test1.h5'

    # path = r'D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\pattern_mgf\test'
    # # path = r'D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\pattern_mgf\\AC_random_F'

    # path =r'D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\pattern_mgf\massbank'
    path =r'D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\pattern_mgf'
    
    files = os.listdir(path)
    for file in files:
        f = os.path.join(path,file)
        # 以mgf结尾
        if not f.endswith('.mgf'):
            continue
        print(file)
        a= mgf_pred(f)
        # mgf_, formula = a.get_halo_spectrum()
        # mgf.write(mgf_,f[:-4]+'_halo.mgf')
        # print(formula)
        # print(len(formula))

        df,mgf_extracted,mgf_patterns,ts=a.get_new()
        df = add_predict(df,model,feature_list)
        df.to_csv(f[:-4]+'_features.csv',index=False)
        # mgf.write(mgf_extracted,f[:-4]+'_extracted.mgf')
        # mgf.write(mgf_patterns,f[:-4]+'_patterns.mgf')
        
        # print(df)
        #遍历整个df
        n = 0
        tn=0
        wrong_formula = []
        mgf_patterns_right =[]
        mgf_extracted_wrong = []
        for i in range(len(df)):
            t = df['true_class'].tolist()[i]
            p = df['class_pred'].tolist()[i]
            # print(t,p)
            if t != p:
                wrong_formula.append(df['formula'].tolist()[i])
                #打印这一行
                # print(df.iloc[i, :]     .T)
                print(t,p)
                n+=1
          
            if t ==0:
                tn+=1

        # for s in mgf_patterns:
        #     if s['params']['ch$formula'] not in wrong_formula:
        #         mgf_patterns_right.append(s)
        # for sp in mgf_extracted:
        #     if sp['params']['ch$formula'] in wrong_formula:
        #         mgf_extracted_wrong.append(sp)
                # print(sp)
        print('----------------')
        
        # mgf.write(mgf_patterns_right,f[:-4]+'_patterns_right.mgf')
        # mgf.write(mgf_extracted_wrong,f[:-4]+'_extracted_wrong.mgf')
        
        print('total spectra: ',ts,'total: ', len(df), '; wrong', n,'multi_halo: ',tn)
        
        print(f,'done')

