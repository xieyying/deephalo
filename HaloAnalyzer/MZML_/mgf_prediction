import sys
sys.path.append(r'\Users\xyy\Desktop\python\HaloAnalyzer')

from pyteomics import mzml ,mgf
import numpy as np
import pandas as pd
from molmass import Formula
import tensorflow as tf
import os
from HaloAnalyzer.Model import model_build
from sklearn.metrics import confusion_matrix,ConfusionMatrixDisplay, classification_report
import matplotlib.pyplot as plt

# your code here
def formula_clf(formula_dict,type=None) :
    """
    Returns a classifier based on the formula given.
    """

    #根据分子式，判断是否可训练
    if formula_dict.get('H') == None or formula_dict.get('C') == None:
        trainable = 'no'
    elif formula_dict.get('H') < 1 or formula_dict.get('C') < 1:
        trainable = 'no'
    elif formula_dict.get('S') != None and formula_dict.get('S') > 4:
        trainable = 'no'
    else:
        trainable = 'yes'

    #根据分子式，判断类别
    if type == 'hydro':
        group = 7

    elif ('Br' in formula_dict.keys()) and ('Cl' in formula_dict.keys()):
        if 'B' in formula_dict.keys() or 'Se' in formula_dict.keys() or 'Fe' in formula_dict.keys():
            group = 17
        else:
            group = 0

    elif ('Br' in formula_dict.keys()) or ('Cl' in formula_dict.keys()):
        if 'B' in formula_dict.keys() or 'Se' in formula_dict.keys() or 'Fe' in formula_dict.keys():
            group = 17
        elif ('Br' in formula_dict.keys()) and formula_dict['Br']>1:
           
            group = 0

        elif ('Cl' in formula_dict.keys()) and formula_dict['Cl']>3:
            group = 0
          
        elif ('Br' in formula_dict.keys()) and formula_dict['Br']==1 :
            group = 1
        elif ('Cl' in formula_dict.keys()) and formula_dict['Cl']==3:
            group = 1
        elif ('Cl' in formula_dict.keys()) and formula_dict['Cl']>=1:
            group = 2
    elif ('Se' in formula_dict.keys() ):
        if formula_dict['Se']==1:
            group = 3
        else:
            group = 15
    elif ('B' in formula_dict.keys()):
        if  formula_dict['B']==1:
            group = 4
        elif formula_dict['B']<=4:
            group = 12
        else:
            group = 13
    elif ('Fe' in formula_dict.keys()):
        if formula_dict['Fe']==1:
            group = 5
        else:
            group = 14
    # elif 'S' in formula_dict.keys():
    #     if formula_dict['S']<=3:
    #         group = 8
    #     elif formula_dict['S']==4:
    #         group = 8
    #     elif formula_dict['S']==5:
    #         group = 8
    # #     else:
    #         group = 8

    else:
        group = 6

    return trainable,group


def mass_spectrum_calc_2(dict_features) -> dict:
    """校正质谱数据"""
    # 将以最高峰为a0的质谱数据转化为以mz最小的峰为m0的质谱数据
    mz_list = [dict_features['mz_b_3'],dict_features['mz_b_2'],dict_features['mz_b_1'],dict_features['mz_b0'],dict_features['mz_b1'],dict_features['mz_b2'],dict_features['mz_b3']]
    ints_list = [dict_features['ints_b_3'],dict_features['ints_b_2'],dict_features['ints_b_1'],1,dict_features['ints_b1'],dict_features['ints_b2'],dict_features['ints_b3']]
    for i in range(len(ints_list)):
        if ints_list[i] != 0:
            index = i
            break
    m0_mz,m1_mz,m2_mz,m3_mz = mz_list[index],mz_list[index+1],mz_list[index+2],mz_list[index+3]
    m0_ints,m1_ints,m2_ints,m3_ints = ints_list[index],ints_list[index+1],ints_list[index+2],ints_list[index+3]
    

    if m2_mz !=0:
        m2_m1 = m2_mz - m1_mz
        m2_m0 = m2_mz - m0_mz
    else:
        m2_m1 = 1.002
        m2_m0 = 2.002

    if m1_mz !=0:
        m1_m0 = m1_mz - m0_mz
    else:    
        m1_m0 = 1.002

    b2= dict_features['mz_b2']
    b1= dict_features['mz_b1']
    if b2 !=0:
        b2_b1 = b2 - b1
    else:
        b2_b1 = 1.002
    

    #以字典的形式返回
    return {'m0_mz':m0_mz,'m1_mz':m1_mz,'m2_mz':m2_mz,'m3_mz':m3_mz,
            'm0_ints':m0_ints,'m1_ints':m1_ints,'m2_ints':m2_ints,'m3_ints':m3_ints,
            'm2_m1':m2_m1,'m2_m0':m2_m0,
            'b2_b1':b2_b1,'m1_m0':m1_m0,}


#误差范围也需要同步传递
def get_mz_max(mz,intensity,target_mz):
    #获取mz中与target_mz相差在0.02的所有mz
    mz_list1 = mz[np.abs(mz-target_mz)<0.02]
    ints_list1 = intensity[np.abs(mz-target_mz)<0.02]
    #获取mz_list1中intensity最大的mz
    mz_max1 = mz_list1[np.argmax(ints_list1)]
    #获取mz_max1对应的intensity
    # intensity_max1 = intensity[np.argmax(intensity[np.abs(mz-target_mz)<0.02])]
    intensity_max1 = ints_list1.max()
    
    #获取mz中与target_mz相差在-3.1和+3.1的所有mz
    mz_list2_index = pd.Series(mz).between((target_mz-3.1),(target_mz+3.1))
    mz_list2 = mz[mz_list2_index]
    ints_list2 = intensity[mz_list2_index]
    #获取mz_list2中intensity最大的mz
    mz_max2 = mz_list2[np.argmax(ints_list2)]
    #获取mz_max2对应的intensity
    # intensity_max2 = intensity[np.argmax(intensity[mz_list2_index])]
    intensity_max2 = ints_list2.max()
    #以字典的形式返回
    return {'mz_list1':mz_list1,'ints_list1':ints_list1,'mz_max1':mz_max1,'intensity_max1':intensity_max1,'mz_list2':mz_list2,'ints_list2':ints_list2,'mz_max2':mz_max2,'intensity_max2':intensity_max2}

#暂未修改
def get_charge(mz_list,ints_list,intensity_max):
    mz_charge_list = mz_list
    ints_charge_list = ints_list/intensity_max
    #选取mz_charge_list中强度最大的前5个峰
    #若不足五个峰，则选取全部
    if len(mz_charge_list) >= 5:
        a = mz_charge_list[ints_charge_list.argsort()[-5:][::-1]]
    else:
        #按照强度顺序排列
        a = mz_charge_list[ints_charge_list.argsort()[::-1]]
    b = []
    for i in a:
        for j in a:
            b.append(i-j)
    b = np.array(b)
    
    b = b.reshape(len(a),len(a))
    # print(b)a
    for i in range(0,len(b)):
        for j in range(0,len(b)):
            if abs(b[i][j] - 1) < 0.02:
                b[i][j] = 1
            elif abs(b[i][j] - 0.5) < 0.02:
                b[i][j] = 0.5
            elif abs(b[i][j] - 0.33) < 0.02:
                b[i][j] = 0.33
            else:
                b[i][j] = 0
    # print(b)
    c = {}
    for i in range(0,len(b)):
        for j in range(0,len(b)):
            if b[i][j] in c:
                c[b[i][j]] += 1
            else:
                c[b[i][j]] = 1
    # print(c)
    d = 0
    for i in c:
        if i != 0:
            if c[i] > d:
                d = c[i]
                e = i
    if d == 0:
        return 0
    if e == 1:
        return 1
    elif e == 0.5:
        return 2
    elif e == 0.33:
        return 3
    else:
        return 0

def get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,delta_mz,error=0.01):
    
    """
    以最高峰为基准，获取与其相差delta_mz的同位素峰的mz和intensity;
    考虑电荷
    允许误差范围为error
    """

    mz = [i for i, x in enumerate(mz_list) if (mz_max+(delta_mz-error)/charge) <= x <= (mz_max+(delta_mz+error)/charge)]
    if len(mz) != 0:
        ints = [ints_list[i] for i in mz]
        mz = mz_list[max(mz, key=lambda i: ints_list[i])]
        ints = max(ints)
    else:
        mz = 0
        ints = 0
    return mz,ints

def get_isotopic_peaks(mz_max,mz_list,ints_list,charge):
    """
    以最高峰为基准，获取同位素峰的mz和intensity;

    """
    mz_b_3,ints_b_3 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,-2.993)
    mz_b_2,ints_b_2 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,-2.000)
    mz_b_1,ints_b_1 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,-0.998)
    mz_b0,ints_b0 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,0.000)
    mz_b1,ints_b1 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,1.001)
    mz_b2,ints_b2 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,2.002)
    mz_b3,ints_b3 = get_one_isotopic_peak(mz_list,ints_list,mz_max,charge,3.003)

    ints_b_3,ints_b_2,ints_b_1,ints_b0,ints_b1,ints_b2,ints_b3 = ints_b_3/ints_b0,\
    ints_b_2/ints_b0,ints_b_1/ints_b0,ints_b0/ints_b0,ints_b1/ints_b0,ints_b2/ints_b0,ints_b3/ints_b0
    mz_b_3,mz_b_2,mz_b_1,mz_b0,mz_b1,mz_b2,mz_b3 = mz_b_3*charge,mz_b_2*charge,mz_b_1*charge,mz_b0*charge,mz_b1*charge,mz_b2*charge,mz_b3*charge
    
    # 根据base数据统计结果去除掉低强度信号，防止背景信号影响
    # min_int_b3: 0.000217286018714 min_int_b1: 0.001998024679028 min_int_b2: 0.0446544604098983 
    # min_int_a1: 0.0218262955587414 min_int_a2: 0.0001238175919807 min_int_a3: 1.244083605286354e-06

    # 根据base数据中含卤素化合物的统计结果去除掉低强度信号，防止背景信号影响
    # min_int_b3: 0.004641895871693 min_int_b1: 0.0075301904935026 min_int_b2: 0.0510192731491299 
    # min_int_a1: 0.0219387819677692 min_int_a2: 0.0265888647368106 min_int_a3: 0.000947965881822

    if ints_b_1 < 0.001:
        mz_b_1 = 0
        ints_b_1 = 0
        mz_b_2 = 0
        ints_b_2 = 0
        mz_b_3 = 0
        ints_b_3 = 0
    else:
        if ints_b_2 < 0.04:
            mz_b_2 = 0
            ints_b_2 = 0
            mz_b_3 = 0
            ints_b_3 = 0
        else:
            if ints_b_3 < 0.0002:
                mz_b_3 = 0
                ints_b_3 = 0
    # 根据b2判断b1是否为杂信号
    # 根据卤化物统计b2为0b1最小为0.223073，根据全部base统计b2为0时b1最小值为0.202336
    if ints_b_2 ==0:
        if ints_b_1 < 0.15:
            mz_b_1 = 0
            ints_b_1 = 0
            mz_b_2 = 0
            ints_b_2 = 0
            mz_b_3 = 0
            ints_b_3 = 0
    
    if ints_b1 < 0.02:
        mz_b1 = 0
        ints_b1 = 0
        mz_b2 = 0
        ints_b2 = 0
        mz_b3 = 0
        ints_b3 = 0
    if mz_b2!=0 and mz_b1!=0:
        b2_b1 = mz_b2-mz_b1
    else:
        b2_b1 = 1.002
    b2_b1_10 = b2_b1**10

    #以字典的形式返回
    return {'b2_b1':b2_b1,'mz_b_3':mz_b_3,'ints_b_3':ints_b_3,'mz_b_2':mz_b_2,'ints_b_2':ints_b_2,'mz_b_1':mz_b_1,'ints_b_1':ints_b_1,'mz_b0':mz_b0,'ints_b0':ints_b0,'mz_b1':mz_b1,'ints_b1':ints_b1,'mz_b2':mz_b2,'ints_b2':ints_b2,'mz_b3':mz_b3,'ints_b3':ints_b3,'b2_b1_10':b2_b1_10}

def is_halo_isotopes(b_3,b_2,b_1,a0,a1,a2,a3):
    """
    根据六个个同位素峰的强度,判断是否为同位素峰
    判断主要依据卤化物的同位素峰强度的统计结果
    """
    # if a1>0.02:
    #     if b_2 == 0:
    #         if b_1==0:
    #             is_isotope = 1
    #         else:
    #             if  b_1 > 0.5:
    #                 is_isotope = 1
    #             else:
    #                 is_isotope = 0
    #     else:
    #         if b_2>0.3:
    #             if b_1>0.02:
    #                is_isotope = 1
    #             else:
    #                 is_isotope = 0
    #         else:
    #             is_isotope = 0
    # else:
    #     is_isotope =0

    # return is_isotope
    if a1>0.02:
        if b_3 == 0:
            is_isotope = 1
        else:
            if b_2 > 0.04:
                is_isotope = 1
            else:
                is_isotope = 0
    else:
        is_isotope =0
    return is_isotope
    
def calculate_zig_zag(I):
    """
    根据一个ROI中所有scan的分类结果，计算ZigZag score
    I:list，为一个ROI中所有scan的分类结果
    """
    # Calculate the maximum and minimum values of I
    Imax= max(I)
    Imin = min(I)
    N = len(I) 
    total = 0
    # Calculate the ZigZag score for I
    for n in range(1,N-1):
        term = (2 * I[n] - I[n - 1] - I[n + 1])**2 

        total += term
    zigzag = total/(N*(Imax-Imin)**2)

    # Convert the ZigZag score to a percentage
    score = (4-8/N-zigzag)/(4-8/N)*100
    # score = (4-8/N-zigzag)/(4-8/N)*100
    return score

def get_max(a):
    '''a 为dict格式的同位素峰数据'''

    # 获得intesity 100%的mz
    for key,value in a.items():
        if round(value[2],4) == 100:
            mz_base = value[0]
        
            break
    return mz_base

def get_cal_mz(formula,mz,ints):
    # get mz_max of formula isotopic pattern
    a = Formula(formula+'H').spectrum().asdict()
    mz_max = get_max(a)            

    mz_list1 = mz[np.abs(mz-mz_max)<0.3]
    ints_list1 = ints[np.abs(mz-mz_max)<0.3]
    if len(mz_list1) != 0:
        precursor_mz = mz_list1[np.argmax(ints_list1)]
        charge_t =1
        # print(precursor_mz)
    else:
        a = Formula(formula+"H"+'H').spectrum().asdict()
        mz_max = get_max(a)
        mz_list1 = mz[np.abs(mz-mz_max/2)<0.3]
        ints_list1 = ints[np.abs(mz-mz_max/2)<0.3]
        if len(mz_list1) != 0:
            precursor_mz = mz_list1[np.argmax(ints_list1)]
            # print(precursor_mz)
            charge_t =2
        else:
            a = Formula(formula+"H"+'H'+'H').spectrum().asdict()
            mz_max= get_max(a)
            mz_list1 = mz[np.abs(mz-mz_max/3)<0.3]
            ints_list1 = ints[np.abs(mz-mz_max/3)<0.3]
            if len(mz_list1) != 0:
                precursor_mz = mz_list1[np.argmax(ints_list1)]
                # print(precursor_mz)
                charge_t =3
            else:
                a = (Formula(formula)-Formula('H')).spectrum().asdict()
                mz_max = get_max(a)
                mz_list1 = mz[np.abs(mz-mz_max)<0.3]
                ints_list1 = ints[np.abs(mz-mz_max)<0.3]
                if len(mz_list1) != 0:
                    precursor_mz = mz_list1[np.argmax(ints_list1)]
                    # print(precursor_mz)
                    charge_t =1
                else:
                    # print('more than 3 charges')
                    precursor_mz = 0
                    charge_t =0
                    
    return precursor_mz, mz_max,charge_t

class mgf_pred():
    def __init__(self,file) -> None:
        self.path = file
        self.spectra = mgf.MGF(file)
        


    def get_new(self):
       
        mgf_extracted = []

        mgf_patterns = []
        
   
        df = pd.DataFrame()
        ts = 0
        for spectrum in self.spectra:
            ts+=1
            mgf_  ={}
            mz = spectrum['m/z array']
            ints = spectrum['intensity array']

            #如果mz中的数值准确到小数点后三位以下，则跳过此循环
            # if (mz*1000 % 1).all() == 0:
            #     continue

            # for MassBank
            try:
                formula = spectrum['params']['ch$formula']
                name = spectrum['params']['ch$name']

            except:
                # for myxo
                formula = spectrum['params']['formula']
                name = spectrum['params']['compound_name']


            # print(formula)

            #强度最低峰
            if ints.size == 0:
                print(formula,'ints is empty')
                continue
            min_int = ints.min()

             # 找到最强峰的index
            max_index = np.argmax(ints)
            max_mz = mz[max_index]
            max_int = ints[max_index]
            # ints = (ints-min_int)/(max_int-min_int)  # for full scan, 对于full scan这种处理比直接除以最大值好，具体表现在同位素提取更准确
            ints = ints/max_int  # for extracted future


            # 去掉峰强小于0.01的峰
            # mz = mz[ints>0.0001]
            # ints = ints[ints>0.0001]
            
            # precursor_mz,mz_max,charge_t = get_cal_mz(formula,mz,ints) # for extracted formula
            precursor_mz = max_mz # for max_mz in full scan
            if precursor_mz == 0:
                continue
            dict_mz_max = get_mz_max(mz, ints, precursor_mz)
            # print(dict_mz_max)
            charge = get_charge(dict_mz_max['mz_list2'],dict_mz_max['ints_list2'],dict_mz_max['intensity_max2'])
            if charge!=0:
                # if charge_t != charge:
                #     print('charge is not equal')
                #     continue
                
                dict_isotoplogues = get_isotopic_peaks(dict_mz_max['mz_max2'],dict_mz_max['mz_list2'],dict_mz_max['ints_list2'],charge)
                is_halo = is_halo_isotopes(dict_isotoplogues['ints_b_3'],dict_isotoplogues['ints_b_2'],dict_isotoplogues['ints_b_1'],dict_isotoplogues['ints_b0'],dict_isotoplogues['ints_b1'],dict_isotoplogues['ints_b2'],dict_isotoplogues['ints_b3'])
                if is_halo == 1:
                    mgf_extracted.append(spectrum)
                    mz_iso = [dict_isotoplogues['mz_b_3'],dict_isotoplogues['mz_b_2'],dict_isotoplogues['mz_b_1'],dict_isotoplogues['mz_b0'],dict_isotoplogues['mz_b1'],dict_isotoplogues['mz_b2'],dict_isotoplogues['mz_b3']]
                    ints_iso = [dict_isotoplogues['ints_b_3'],dict_isotoplogues['ints_b_2'],dict_isotoplogues['ints_b_1'],dict_isotoplogues['ints_b0'],dict_isotoplogues['ints_b1'],dict_isotoplogues['ints_b2'],dict_isotoplogues['ints_b3']]
                    mgf_['params'] = spectrum['params']
                    # 非零mz和intensity
                    mgf_['m/z array'] = np.array(mz_iso)[np.array(mz_iso)!=0]
                    mgf_['m/z array'] =mgf_['m/z array'] * charge
                    mgf_['intensity array'] = np.array(ints_iso)[np.array(ints_iso)!=0]
                    # mgf_['m/z array'] = np.array(mz_iso)
                    # mgf_['intensity array'] = np.array(ints_iso)
                    mgf_patterns.append(mgf_)
            else:
                # print('charge is 0')
                continue
            monoisotope = get_max(Formula(formula).spectrum().asdict())
            true_class = formula_clf(Formula(formula).composition().dataframe().to_dict()['Count'])[1]


            #应该将函数的返回值修改为字典，可以避免重复修改此处代码    
            dict_new = mass_spectrum_calc_2(dict_isotoplogues)
            dict_new['charge'] = charge
            dict_new['formula'] = formula
            dict_new['mz_monoisotope'] = monoisotope
            dict_new['mz_precursor'] = precursor_mz
            dict_new['name'] = name
            dict_new['is_halo'] = is_halo
            dict_new['true_class'] = true_class
            dict_all = dict_isotoplogues.copy()
            dict_all.update(dict_new)
            df = pd.concat([df, pd.Series(dict_all)], axis=1)

        df = df.T
        # df = df[df['charge']!=0]
        # df = df[df['is_halo']==1]
        # df.to_csv('D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\myxo_abstracted_isotopes_features1.csv',index=False)
        # df.to_csv('D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\isotopes features.csv',index=False)
        # print(df)
        return df,mgf_extracted,mgf_patterns,ts

    def get_halo_spectrum(self):
        halo_formula = []
        
        mgf_halo = []

        for spectrum in self.spectra:
            # formula = spectrum['params']['ch$formula']
            try:
                formula = spectrum['params']['ch$formula']
                name = spectrum['params']['ch$name']

            except:
                # for myxo
                formula = spectrum['params']['formula']
                name = spectrum['params']['compound_name']

            true_class = formula_clf(Formula(formula).composition().dataframe().to_dict()['Count'])[1]
            if true_class in [0,1,2]:
                mgf_halo.append(spectrum)
                halo_formula.append(formula)

        return mgf_halo, halo_formula


def add_predict(df,model_path,features_list):
    
#加载tf模型
    # root_csw_weights = [0.00808743,0.00690296, 0.0050516,  0.00997609, 0.00953029, 0.010005,0.00342269, 0.00334737]
    # def root_csw_loss(y_true, y_pred):
    #     weights = tf.gather(root_csw_weights, tf.cast(y_true, tf.int32))
    #     weights = tf.cast(weights, tf.float32)
    #     return tf.reduce_mean(tf.losses.sparse_categorical_crossentropy(y_true, y_pred) * weights)
    # clf = tf.keras.models.load_model(model_path,custom_objects={'root_csw_loss': root_csw_loss})
    clf = tf.keras.models.load_model(model_path)
    
    #加载特征

    querys = df[features_list].values
    querys = querys.astype('float32')
    #对特征进行预测
    res = clf.predict(querys)
    # classes = tf.math.argmax(res[0],1).numpy()
    classes_pred = np.argmax(res, axis=1)
    #将预测结果添加到df_features中
    df['class_pred'] = classes_pred

    return df
def confusion_show(df):
        # # Compute confusion matrix
        Y_val = df['true_class'].astype('int').values
        y_pred = df['class_pred'].astype('int').values
        #y_pred中的7换为6
        y_pred[y_pred==7] = 6
        print(type(Y_val),type(y_pred))
        cm = confusion_matrix(Y_val, y_pred)

        # Compute recall and precision for each class
        report = classification_report(Y_val, y_pred, output_dict=True,zero_division=0)
        # Compute recall and precision for each class
        report = classification_report(Y_val, y_pred, output_dict=True,zero_division=1)
        recalls = [report[str(i)]['recall'] if str(i) in report else 0 for i in range(cm.shape[0])]
        precisions = [report[str(i)]['precision'] if str(i) in report else 0 for i in range(cm.shape[0])]
        F1_sore = [report[str(i)]['f1-score'] if str(i) in report else 0 for i in range(cm.shape[0])]

        # Plot the confusion matrix
        fig, axs = plt.subplots(2, 2, figsize=(10, 10))

        # Plot the confusion matrix
        ConfusionMatrixDisplay.from_predictions(Y_val, y_pred, ax=axs[0, 0], cmap=plt.cm.terrain)
        axs[0, 0].set_title('Classifier')
        # Plot the precision bar chart below the confusion matrix
        # Plot the precision bar chart below the confusion matrix
        colors = np.random.rand(len(precisions), 3)
        axs[1, 0].bar(np.arange(len(precisions)), precisions, color=colors)
        axs[1, 0].set_title('Precision')
        axs[1, 0].set_xlabel('Class')
        axs[1, 0].set_ylabel('Precision')
        #将数值标注在图上
        for i, v in enumerate(precisions):
            axs[1, 0].text(i - 0.25, v + 0.01, str(round(v, 3)), color='black', fontweight='bold')

        # Plot the recall bar chart to the right of the confusion matrix
        
        axs[0, 1].barh(np.arange(len(recalls)), recalls, color=colors)
        axs[0, 1].set_title('Recall')
        axs[0, 1].set_xlabel('Recall')
        axs[0, 1].set_ylabel('Class')
        #将数值标注在图上
        for i, v in enumerate(recalls):
            axs[0, 1].text(v + 0.01, i + .25, str(round(v, 3)), color='black', fontweight='bold')
        axs[0, 1].invert_yaxis()  # Reverse the y-axis so class 0 is on top
        axs[0, 1].set_xlim(0, 1)  # Set the x-axis range to 0-1

        # Plot the f1-score bar chart below the recall bar chart
        axs[1, 1].bar(np.arange(len(F1_sore)), F1_sore, color=colors)
        axs[1, 1].set_title('F1-score')
        axs[1, 1].set_xlabel('Class')
        axs[1, 1].set_ylabel('F1-score')
        #将数值标注在图上
        for i, v in enumerate(F1_sore):
            axs[1, 1].text(i - 0.25, v + 0.01, str(round(v, 3)), color='black', fontweight='bold')
        axs[1, 1].set_ylim(0, 1)
        # axs[1, 1].set_xlim(0, 1)

        plt.tight_layout()
        plt.show()

if __name__ == '__main__':
    
    feature_list = [
        "ints_b_3",
        "ints_b_2",
        "ints_b_1",
        "ints_b0",
        "ints_b1",
        "ints_b2",
        "ints_b3",
        "m2_m1",
        "m1_m0",
        "b2_b1",
        
    ]
    # model=r'C:\Users\xyy\Desktop\python\HaloAnalyzer_training\main10\trained_models\pick_halo_ann.h5'
    model = r'C:\Users\xyy\Desktop\python\HaloAnalyzer_training\020_main_5\trained_models\pick_halo_ann.h5'
    # model = r'C:\Users\xyy\Desktop\python\HaloAnalyzer_training\020_main_1\trained_models\picked_models\pick_halo_ann_test1.h5'

    # path = r'D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\pattern_mgf\test'
    # # path = r'D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\pattern_mgf\\AC_random_F'

    # path =r'D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\pattern_mgf\massbank'
    path =r'D:\python\wangmengyuan\dataset\mzmls\mgf_from_public_database\pattern_mgf\isotope_patterns_mgf_merged'
    
    files = os.listdir(path)
    for file in files:
        f = os.path.join(path,file)
        # 以mgf结尾
        if not f.endswith('.mgf'):
            continue
        print(file)
        a= mgf_pred(f)
        # mgf_, formula = a.get_halo_spectrum()
        # mgf.write(mgf_,f[:-4]+'_halo.mgf')
        # print(formula)
        # print(len(formula))

        df,mgf_extracted,mgf_patterns,ts=a.get_new()
        df = add_predict(df,model,feature_list)
        df.to_csv(f[:-4]+'_features.csv',index=False)
        # mgf.write(mgf_extracted,f[:-4]+'_extracted.mgf')
        # mgf.write(mgf_patterns,f[:-4]+'_patterns.mgf')
        
        # print(df)
        #遍历整个df
        n = 0
        tn=0
        wrong_formula = []
        mgf_patterns_right =[]
        mgf_extracted_wrong = []
        
        for i in range(len(df)):
            t = df['true_class'].tolist()[i]
            p = df['class_pred'].tolist()[i]
            # print(t,p)
            if t != p:
                wrong_formula.append(df['formula'].tolist()[i])
                #打印这一行
                # print(df.iloc[i, :]     .T)
                print(t,p)
                n+=1
          
            if t ==0:
                tn+=1

        # for s in mgf_patterns:
        #     if s['params']['ch$formula'] not in wrong_formula:
        #         mgf_patterns_right.append(s)
        # for sp in mgf_extracted:
        #     if sp['params']['ch$formula'] in wrong_formula:
        #         mgf_extracted_wrong.append(sp)
                # print(sp)
        print('----------------')
        
        # mgf.write(mgf_patterns_right,f[:-4]+'_patterns_right.mgf')
        # mgf.write(mgf_extracted_wrong,f[:-4]+'_extracted_wrong.mgf')
        
        print('total spectra: ',ts,'total: ', len(df), '; wrong', n,'multi_halo: ',tn)
        confusion_show(df)
        # print(f,'done')

# 0 = 0.00808743
# 1 = 0.00690296
# 2 = 0.0050516
# 3 = 0.00997609
# 4 = 0.00953029
# 5 = 0.010005
# 6 = 0.00342269
# 7 = 1